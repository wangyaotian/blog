#### 一、Redis简介

##### 1、什么是Redis？

- Redis本质上是一个Key-Value类型的内存数据库，很像mamcached
- 整个数据库统统加载在内存当中进行操作，定期通过异步操作吧数据库数据flush到硬盘上进行保存
- 因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-ValueDB

##### 2、Redis特点

1. redis笔mamcached优点
    1. 数据类型：redis支持五种数据类型，memcached所有的值均是简单的字符串
    2. value大小限制：redis单个value的最大限制是512M，memcached只能保存1MB的数据
    3. 持久化：redis可以持久化，memcached不支持持久化
2. redis为什么快？
    1. 纯内存操作
    2. 单线程避免上下文切换
    3. 非阻塞IO多路复用机制
3. redis缺点
    1. 内存限制：不能用作海量数据存储
    2. 注：如果需要存储海量数据，可以使用MongoDb

#### 二、Redis内存碎片

- 什么是内存碎片
    - 你可以将内存碎片简单地理解为那些不可用的空闲内存
    - 举个例子
        - 操作系统为你分配了32字节的连续内存空间，而你存储数据实际只需要使用24字节内存空间
        - 那这多余出来的8字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片
- 产生内存碎片原因
    - 申请的空间大于实际存储的空间
    - 某个数据删除时，Redis通常不会轻易释放内存给操作系统

#### 三、Redis阻塞

- O(n)复杂度命令
    - Redis中的大部分命令都是O(1)时间复杂度，但也有少部分O(n)时间复杂度的命令
    - KEYS*:会返回所有符合规则的key
    - HGETALL:会返回一个Hash中所有的键值对
    - LRANGE：会返回list中指定氛围内的元素
    - SMEMBERS：返回Set中的所有元素
    - SINTER/SUNION/SDIFF:计算多个set的交集/并集/差集
- SAVE创建RDB快照
    - save:同步保存操作，会阻塞Redis主线程
    - basave：fork出一个子进程，子进程执行，不会阻塞Redis主线程，默认选项
        - 默认情况下，Redis默认配置会使用bgsave命令
        - 如果手动使用save命令生成RDB快照文件的话，就会阻塞主线程
- AOF日志记录阻塞Redis
    - AOF持久化机制是在执行完命令之后再记录日志
- 大Key
    - 如果一个key对应的value所占用的内存比较大，那这个key就可以看做是bigkey
    - 具体多大才算大呢？有一个不是特别精确的参考标准
        - string类型的value超过1MB
        - 复合类型（列表、哈希、集合、有序集合等）的value包含的元素超过5000个
    - 大key造成的阻塞问题如下
        - 客户端超时阻塞
        - 引发网络阻塞：如果一个key的大小是1MB，每秒访问量为1000，那么每秒会产生1000MB的流量
        - 阻塞工作线程：如果使用del删除大key时，会阻塞工作线程