## 一、Redis淘汰策略
- 先说结论：Redis是使用定期删除+惰性删除两者配合的过期策略
### 1、过期策略
#### 1、为什么要淘汰
- 一般情况下，当内存超出物理内存限制时，内存数据将与磁盘产生频繁交换（swap）
- swap会导致Redis性能急剧下降，对于访问量比较频繁的情况下，swap的存取效率会让服务基本处于不可用状态
- 在生产环境中，一般不允许Redis出现swap行为，Redis提供了maxmemory设置其最多可占用得内存空间
- 当Redis使用的内存超出maxmemory时，此时已经没有多余可用的内存空间，新的数据将无法写入
- Redis提供了几种数据淘汰策略，用于清理数据，以保证Redis的可用空间

#### 2、定期删除（不推荐）
- 定期删除指的是Redis默认每隔100ms就随机抽取一些设置了过期时间的key，检测这些key是否过期，如果过期了就将其删掉
- 因为key太多，如果全盘扫描所有的key会非常耗性能，所以是随机抽取一些key来删除这样就有可能删除不玩，需要惰性删除配合
- 定期删除是一种简单粗暴的方法，它可以保证过期的key最终一定会被删除，但是它也有缺点：
  - 为了保证效率，Redis会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响
  - 定期删除策略并不能保证过期的key一定会被删除，因为它只是随机抽取一些key来删除，而不是扫描所有的key
 
#### 3、惰性删除
- 惰性删除不再是Redis去主动删除，而是在客户端要获取某个key的时候，Redis会先去检测一下这个key是否过期
- 如果没有过期则返回给客户端，如果过期了，那么Redis会删除这个key，不会返回给客户端
- 所以惰性删除可以解决一些过期了，但没被定期删除随机抽取到的这些key
- 但有些过期的key既没有被随机抽取，也没有被客户端访问，就会一直保留在数据库，占用内存空间，长期下午可能会导致Redis内存耗尽
- 所以惰性删除也有缺点：
  - 惰性删除无法保证过期的key一定会被删除，因为它只是在客户端要获取某个key的时候才会去检测这个key是否过期
  - 惰性删除也会导致Redis内存占用过多，因为过期的key不会被删除，而是一直保留在数据库中

### 2、内存淘汰机制
> - 在Redis中,volatile-ttl和volatile-lru策略并不是真正的过期才会被淘汰
> - 而是只有当键设置了过期时间(TTL),并且在内存满时，就会按照策略淘汰

|序号 | maxmemory-policy        | 含义          | 特性                                                               |
|---|-------------------------|-------------|------------------------------------------------------------------|
|1| noeviction<br/>Redis默认策略 | 不淘汰         | 内存超限后写命令会返回错误（如OOM，del命令除外）<br/>即可读不可写，该策略不会丢失数据，是默认策略           |
|2| volatile-lru            | 最久未使用的键     | 淘汰具有过期时间的key，最少使用的key优先淘汰，<br/>没有过期时间的key不会被淘汰，该策略可以保证持久化的数据不被丢失 |
|3| volatile-ttl            | 即将过期的键      | 与2类似，区别是比较过期时间ttl的值，值越小越优先淘汰                                     |
|4| volatile-random         | 易失key的随机    | 与2、3类似，区别是随机淘宝具备过期时间的key、不分使用频率和过期时间长短                           |
|5| allkeys-lru             | 所有key的LRU机制 | 与2类似，不过该淘汰策略范围是Redis中的所有key，不区分是否有过期时间，但是区分使用频率                  |
|6| vallkeys-random         | 所有key随机淘汰   | 与5类似，范围是所有的key，但是不区分使用频率                                         |

### 3、持久化如何处理过期？
> 在持久化和数据恢复阶段，对过期key也有一些特殊的处理

- RDB
  - 从内存数据库持久化数据到RDB文件：持久化key之前，会检查是否过期，过期的key不进入RDB文件
  - 从RDB文件恢复数据到内存数据库：数据载入数据库之前，会对key先进行过期检查，如果过期，就不载入内存数据库
- AOF
  - 从内存数据库持久化数据到AOF文件
    - 当key过期后，还没有被删除，此时进行执行持久化操作(该key是不会进入aof文件的，因为没有发生修改命令)
    - 当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令。（在将来的以aof文件恢复数据的时候该过期的键就会被删除）
  - AOF重写：重写时，会先判断key是否过期，已过期的key不会被写入到重写后的aof文件中

### 4、Redis的LRU
> 传统LRU算法弊端
- 传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶
- 但是用栈的形式，每次都需要将栈中的数据进行移动，性能较差
> Redis3.0中的LRU算法
- Redis每次按key获取一个值的时候，都会更新value中的lru字段为当前秒级别的时间戳
- Redis初始的实现算法很简单，随机从dict中取出五个key，淘汰一个lru字段值最小的
- 在3.0的时候，又改进了算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16)，pool中的key是按lru大小顺序排列的
- 接下来每次随机选取的key lru值必须小于pool中最小的lru值，才能放入pool中，直到pool满为止
- 放满之后，每次如果有新的key需要放入。需要将pool中lru最大的一个key取出
- 淘汰的时候，直接从pool中取出lru最小的一个key即可

### 5、Redis如何发现热点key
- 凭借经验,进行预估：例如提前知道了某个活动的开启，那么就将此key作为热点key
- 服务端收集：在操作Redis之前，加入一行代码进行数据统计
- 抓包进行评估：Redis使用TCP协议与客户端进行通信，通信协议采用的是RESP，所以自己写程序监听端口也能进行拦截包进行解析
- 在proxy层，对每一个Redis请求进行收集上报
- Redis自带命令查询：Redis版本提供了Redis-cli-hotkeys就能找出热点key
  - 如果要用REdis自带命令查询时，要注意需要先把内存逐出策略设置为allkeys-lfu或者