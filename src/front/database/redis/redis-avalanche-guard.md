### 缓存穿透

> 查询一个不存在的key

- 定义
  - 缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，接着查询数据库也无法查询出结果
  - 虽然也不会写入到缓存中，但是这将会导致每个查询都会去请求数据库，造成缓存穿透
- 解决方法：布隆过滤
  - 对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃,从而避免了对底层存储系统的查询压力

### 缓存击穿

>热点key突然失效，大量请求打到数据库

- 定义
  - 缓存击穿是指在高并发场景下，某个热点key在失效的瞬间，有大量的请求同时访问这个key，导致这些请求都打到了数据库，造成了数据库的压力过大
- 解决方法
  - 热点数据不过期
  - 加互斥锁
    - 互斥锁：当发现key不存在时，通过加锁或者队列来控制只有一个请求去数据库查询数据，其他请求等待，从而避免了缓存击穿
    - 缓存失效时，通过加锁或者队列来控制只有一个请求去数据库查询数据，其他请求等待，从而避免了缓存击穿 

### 缓存雪崩

> 缓存雪崩是指在高并发场景下，缓存中的大量key同时失效或者缓存服务器宕机，导致大量请求直接打到数据库，造成数据库的压力过大

- 定义
  - 缓存雪崩是指在高并发场景下，缓存中的大量key同时失效或者缓存服务器宕机，导致大量请求直接打到数据库，造成数据库的压力过大
- 解决方法
  - 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生
  - 缓存服务器的高可用，避免缓存服务器宕机

### 布隆过滤器是什么？

> 布隆过滤器是一种空间效率高的概率型数据结构，用于判断一个元素是否在一个集合中

- 本质上上布隆过滤器是一种数据结构，比较巧妙的概率性数据结构
- 特点是高效地插入和查询，可以用来告诉你“某样东西一定不存在或者可能存在”
- 相比于传统的List、Set、Map等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的
- **使用：**
  - 布隆过滤器在NoSQL数据库领域中应用的非常广泛
  - 当用户来查询某一个row时，可以先通过内存中的布隆过滤器过滤掉大量不存在的row请求，然后再去磁盘进行查询
  - 布隆过滤器说某个值不存在时，那肯定就是不存在，可以显著降低数据库IO请求数量

### 应用场景

- 场景1（给用户推荐新闻）
  - 当用户看过的新闻，肯定会被过滤掉。对于没有看过的新闻，可能会过滤极少的一部分（误判）
  - 这样可以完成保证推送给用户的新闻都是无重复的
- 场景2（爬虫url去重）
  - 在爬虫系统中，我们需要对url去重,已经爬取的页面不再爬取
  - 当url高达几千万时，如果一个集合去装下这些URL地址非常浪费空间
  - 使用布隆过滤器可以大幅降低去重存储消耗，只不过也会使爬虫系统错过少量页面

### 布隆过滤器原理
- 每个布隆过滤器对应到Redis的数据结构是一个大型的数组和几个不一样的无偏hash函数
- 如下图:f、g、h是三个不同的hash函数(无偏差指让hash映射到数组的位置比较随机)
- **添加**：值到布隆过滤器
  - 向布隆过滤器添加key，会使用f、g、h hash函数对key算出一个整数索引，然后对长度取余
  - 每个hash函数都会算出一个不同的位置，把算出的位置都设置成1就完成了布隆过滤器添加过程
- **查询**：布隆过滤器值
  - 当查询某个key时，先用hash函数算出一个整数索引，然后对长度取余
  - 当你有一个不为1时肯定不存在这个key，当全部都为1时可能有这个key
  - 这样内存中的布隆过滤器过滤掉大量不存在的row请求，然后再去磁盘进行查询，减少IO操作
- **删除**：不支持
  - 目前我们知道布隆过滤器可以支持add和isExist操作
  - 如何解决这个问题，答案是计数删除，但是计数删除需要存储一个数值，而不是原先的bit位，会增大空间占用

![img](http://v5blog.cn/assets/img/image-20210119145653913.4f59f4b2.png)