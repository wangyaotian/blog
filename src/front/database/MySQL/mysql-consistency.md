#### 一、如何保证mysql和redis一致性

##### 1、说明

- 没有完美的方案，只有最适合某场景的方案
- 这个是数据一致性、系统性性能和系统复杂度的选择与取舍

##### 2、先更新MySQL，在更新Redis

1. 如果先更新mysql成功了，还未对redis进行更新和间隙期，这时如果请求过来，读到的都是redis的更新前数据
2. 如果先更新MysQL成功了，再更新redis失败了的话，后面的请求读到的都是Redis的更新前数据，并且后续的补救方案很难做
3. 补救方案一
    1. 为Redis更新失败，将mysql中的对应数据也回滚了，以此达到两者数据的一致性
    2. 但mysql是主数据源，它代表的数据的权威性，这样做显然并不合理
4. 补救方案二
    1. 通过Redis重试更新的方式进行补救。但如果重试也失败了，还要继续重试吗？
    2. 另外，重试时间间隔设置多少？时间间隔设置长了，影响业务的时间也会变长
    3. 时间间隔设置短了，重试成功率又会降低，这些其实都是问题

##### 3、先更新Redis，再更新MysqL

- 这个方案，要比方案一的先更新MysQL，在更新Redis合理一些
- 原因在于更新完Redis的话，哪怕还没更新Mysql，这时如果请求过来，读到的都是Redis更新后的新数据
- 另外，先更新Redis成功，再更新Mysql失败，可以通过再删除redis所对应的数据进行补救
- 缺点：读到的都是Redis未生效的新数据

##### 4、先更新mysql，再删除Redis

1. 如果先更新MySQL成功了，还未对Redis进行删除的间隙期，这时如果请求过来，读到的都是Redis的删除前数据
2. 如果先更新MySQL成功了，再删除Redis失败了的话，后面的请求读到的都是Redis的删除前数据，并且后续的补救方案很难做

##### 5、先删除Redis，在更新MySQl

1. 如果先删除Redis成功了，还未对Mysql进行更新的间隙期
2. 只存在于Mysql一个存储载体中，也就没有了数据一致性的问题
3. 如果先删除Redis成功了，再更新MysqL失败了的话
4. 只存在于Mysql一个存储载体中，所谓的补救方案也就不需要了，直接当这条数据没更新成功
5. 产生问题
    1. 某商品的库存数为10个，用户A购买一件商品时进行库存扣减，因此第一步先删除了Redis中的库存数
    2. 这时，用户B查询该商品的库存，发现Redis中并没有该商品的库存，于是从Mysql中读取库存数后，写入到了Redis中（10个）
    3. 然后，用户A更新数据库，将库存数从10个扣减到9个
    4. 最终，Redis中的库存数是10个，mysql中的库存数是9个

##### 6、分布式锁

- 分布式锁完全可以解决一致性问题，但是性能会降低，我们设置缓存的目的就是为了性能

